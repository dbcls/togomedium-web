{"version":3,"file":"gmdb-find-media-by-taxonomic-tree.js","sources":["../../../home/runner/work/togomedium-web/togomedium-web/node_modules/.pnpm/@tanstack+query-core@5.67.3/node_modules/@tanstack/query-core/build/modern/queriesObserver.js","../../../home/runner/work/togomedium-web/togomedium-web/node_modules/.pnpm/@tanstack+react-query@5.67.3_react@19.0.0/node_modules/@tanstack/react-query/build/modern/useQueries.js","../../../home/runner/work/togomedium-web/togomedium-web/node_modules/.pnpm/usehooks-ts@3.1.1_react@19.0.0/node_modules/usehooks-ts/dist/index.js"],"sourcesContent":["// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep } from \"./utils.js\";\nfunction difference(array1, array2) {\n  return array1.filter((x) => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  #observerMatches = [];\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#observers.forEach((observer) => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options, notifyOptions) {\n    this.#queries = queries;\n    this.#options = options;\n    if (process.env.NODE_ENV !== \"production\") {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash\n      );\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          \"[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.\"\n        );\n      }\n    }\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      this.#observerMatches = newObserverMatches;\n      newObserverMatches.forEach(\n        (match) => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions)\n      );\n      const newObservers = newObserverMatches.map((match) => match.observer);\n      const newResult = newObservers.map(\n        (observer) => observer.getCurrentResult()\n      );\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index]\n      );\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.#observers = newObservers;\n      this.#result = newResult;\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#result;\n  }\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(\n      (match) => match.observer.getOptimisticResult(match.defaultedQueryOptions)\n    );\n    return [\n      result,\n      (r) => {\n        return this.#combineResult(r ?? result, combine);\n      },\n      () => {\n        return this.#trackResult(result, matches);\n      }\n    ];\n  }\n  #trackResult(result, matches) {\n    return matches.map((match, index) => {\n      const observerResult = result[index];\n      return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, (accessedProp) => {\n        matches.forEach((m) => {\n          m.observer.trackProp(accessedProp);\n        });\n      }) : observerResult;\n    });\n  }\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input)\n        );\n      }\n      return this.#combinedResult;\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer])\n    );\n    const observers = [];\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        });\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions)\n        });\n      }\n    });\n    return observers;\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches);\n      const newResult = this.#combineResult(newTracked, this.#options?.combine);\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n};\nexport {\n  QueriesObserver\n};\n//# sourceMappingURL=queriesObserver.js.map","\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager\n} from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(\n    () => queries.map((opts) => {\n      const defaultedOptions = client.defaultQueryOptions(\n        opts\n      );\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    }),\n    [queries, client, isRestoring]\n  );\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new QueriesObserver(\n      client,\n      defaultedQueries,\n      options\n    )\n  );\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(\n    defaultedQueries,\n    options.combine\n  );\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop,\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options,\n      {\n        listeners: false\n      }\n    );\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some(\n    (result, index) => shouldSuspend(defaultedQueries[index], result)\n  );\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index];\n      return query && getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: query.throwOnError,\n        query: client.getQueryCache().get(query.queryHash),\n        suspense: query.suspense\n      });\n    }\n  );\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport {\n  useQueries\n};\n//# sourceMappingURL=useQueries.js.map","import { useState, useCallback, useLayoutEffect, useEffect, useRef, useMemo } from 'react';\nimport debounce from 'lodash.debounce';\n\n// src/useBoolean/useBoolean.ts\nfunction useBoolean(defaultValue = false) {\n  if (typeof defaultValue !== \"boolean\") {\n    throw new Error(\"defaultValue must be `true` or `false`\");\n  }\n  const [value, setValue] = useState(defaultValue);\n  const setTrue = useCallback(() => {\n    setValue(true);\n  }, []);\n  const setFalse = useCallback(() => {\n    setValue(false);\n  }, []);\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n  return { value, setValue, setTrue, setFalse, toggle };\n}\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n// src/useEventListener/useEventListener.ts\nfunction useEventListener(eventName, handler, element, options) {\n  const savedHandler = useRef(handler);\n  useIsomorphicLayoutEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  useEffect(() => {\n    const targetElement = (element == null ? void 0 : element.current) ?? window;\n    if (!(targetElement && targetElement.addEventListener))\n      return;\n    const listener = (event) => {\n      savedHandler.current(event);\n    };\n    targetElement.addEventListener(eventName, listener, options);\n    return () => {\n      targetElement.removeEventListener(eventName, listener, options);\n    };\n  }, [eventName, element, options]);\n}\n\n// src/useClickAnyWhere/useClickAnyWhere.ts\nfunction useClickAnyWhere(handler) {\n  useEventListener(\"click\", (event) => {\n    handler(event);\n  });\n}\nfunction useCopyToClipboard() {\n  const [copiedText, setCopiedText] = useState(null);\n  const copy = useCallback(async (text) => {\n    if (!(navigator == null ? void 0 : navigator.clipboard)) {\n      console.warn(\"Clipboard not supported\");\n      return false;\n    }\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText(text);\n      return true;\n    } catch (error) {\n      console.warn(\"Copy failed\", error);\n      setCopiedText(null);\n      return false;\n    }\n  }, []);\n  return [copiedText, copy];\n}\nfunction useCounter(initialValue) {\n  const [count, setCount] = useState(initialValue ?? 0);\n  const increment = useCallback(() => {\n    setCount((x) => x + 1);\n  }, []);\n  const decrement = useCallback(() => {\n    setCount((x) => x - 1);\n  }, []);\n  const reset = useCallback(() => {\n    setCount(initialValue ?? 0);\n  }, [initialValue]);\n  return {\n    count,\n    increment,\n    decrement,\n    reset,\n    setCount\n  };\n}\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    if (delay === null) {\n      return;\n    }\n    const id = setInterval(() => {\n      savedCallback.current();\n    }, delay);\n    return () => {\n      clearInterval(id);\n    };\n  }, [delay]);\n}\n\n// src/useCountdown/useCountdown.ts\nfunction useCountdown({\n  countStart,\n  countStop = 0,\n  intervalMs = 1e3,\n  isIncrement = false\n}) {\n  const {\n    count,\n    increment,\n    decrement,\n    reset: resetCounter\n  } = useCounter(countStart);\n  const {\n    value: isCountdownRunning,\n    setTrue: startCountdown,\n    setFalse: stopCountdown\n  } = useBoolean(false);\n  const resetCountdown = useCallback(() => {\n    stopCountdown();\n    resetCounter();\n  }, [stopCountdown, resetCounter]);\n  const countdownCallback = useCallback(() => {\n    if (count === countStop) {\n      stopCountdown();\n      return;\n    }\n    if (isIncrement) {\n      increment();\n    } else {\n      decrement();\n    }\n  }, [count, countStop, decrement, increment, isIncrement, stopCountdown]);\n  useInterval(countdownCallback, isCountdownRunning ? intervalMs : null);\n  return [count, { startCountdown, stopCountdown, resetCountdown }];\n}\nfunction useEventCallback(fn) {\n  const ref = useRef(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return useCallback((...args) => {\n    var _a;\n    return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);\n  }, [ref]);\n}\n\n// src/useLocalStorage/useLocalStorage.ts\nvar IS_SERVER = typeof window === \"undefined\";\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { initializeWithValue = true } = options;\n  const serializer = useCallback(\n    (value) => {\n      if (options.serializer) {\n        return options.serializer(value);\n      }\n      return JSON.stringify(value);\n    },\n    [options]\n  );\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return defaultValue;\n      }\n      return parsed;\n    },\n    [options, initialValue]\n  );\n  const readValue = useCallback(() => {\n    const initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;\n    if (IS_SERVER) {\n      return initialValueToUse;\n    }\n    try {\n      const raw = window.localStorage.getItem(key);\n      return raw ? deserializer(raw) : initialValueToUse;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \\u201C${key}\\u201D:`, error);\n      return initialValueToUse;\n    }\n  }, [initialValue, key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  });\n  const setValue = useEventCallback((value) => {\n    if (IS_SERVER) {\n      console.warn(\n        `Tried setting localStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    try {\n      const newValue = value instanceof Function ? value(readValue()) : value;\n      window.localStorage.setItem(key, serializer(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new StorageEvent(\"local-storage\", { key }));\n    } catch (error) {\n      console.warn(`Error setting localStorage key \\u201C${key}\\u201D:`, error);\n    }\n  });\n  const removeValue = useEventCallback(() => {\n    if (IS_SERVER) {\n      console.warn(\n        `Tried removing localStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n    window.localStorage.removeItem(key);\n    setStoredValue(defaultValue);\n    window.dispatchEvent(new StorageEvent(\"local-storage\", { key }));\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"local-storage\", handleStorageChange);\n  return [storedValue, setValue, removeValue];\n}\nvar IS_SERVER2 = typeof window === \"undefined\";\nfunction useMediaQuery(query, {\n  defaultValue = false,\n  initializeWithValue = true\n} = {}) {\n  const getMatches = (query2) => {\n    if (IS_SERVER2) {\n      return defaultValue;\n    }\n    return window.matchMedia(query2).matches;\n  };\n  const [matches, setMatches] = useState(() => {\n    if (initializeWithValue) {\n      return getMatches(query);\n    }\n    return defaultValue;\n  });\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n  useIsomorphicLayoutEffect(() => {\n    const matchMedia = window.matchMedia(query);\n    handleChange();\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener(\"change\", handleChange);\n    }\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener(\"change\", handleChange);\n      }\n    };\n  }, [query]);\n  return matches;\n}\n\n// src/useDarkMode/useDarkMode.ts\nvar COLOR_SCHEME_QUERY = \"(prefers-color-scheme: dark)\";\nvar LOCAL_STORAGE_KEY = \"usehooks-ts-dark-mode\";\nfunction useDarkMode(options = {}) {\n  const {\n    defaultValue,\n    localStorageKey = LOCAL_STORAGE_KEY,\n    initializeWithValue = true\n  } = options;\n  const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY, {\n    initializeWithValue,\n    defaultValue\n  });\n  const [isDarkMode, setDarkMode] = useLocalStorage(\n    localStorageKey,\n    defaultValue ?? isDarkOS ?? false,\n    { initializeWithValue }\n  );\n  useIsomorphicLayoutEffect(() => {\n    if (isDarkOS !== isDarkMode) {\n      setDarkMode(isDarkOS);\n    }\n  }, [isDarkOS]);\n  return {\n    isDarkMode,\n    toggle: () => {\n      setDarkMode((prev) => !prev);\n    },\n    enable: () => {\n      setDarkMode(true);\n    },\n    disable: () => {\n      setDarkMode(false);\n    },\n    set: (value) => {\n      setDarkMode(value);\n    }\n  };\n}\nfunction useUnmount(func) {\n  const funcRef = useRef(func);\n  funcRef.current = func;\n  useEffect(\n    () => () => {\n      funcRef.current();\n    },\n    []\n  );\n}\n\n// src/useDebounceCallback/useDebounceCallback.ts\nfunction useDebounceCallback(func, delay = 500, options) {\n  const debouncedFunc = useRef();\n  useUnmount(() => {\n    if (debouncedFunc.current) {\n      debouncedFunc.current.cancel();\n    }\n  });\n  const debounced = useMemo(() => {\n    const debouncedFuncInstance = debounce(func, delay, options);\n    const wrappedFunc = (...args) => {\n      return debouncedFuncInstance(...args);\n    };\n    wrappedFunc.cancel = () => {\n      debouncedFuncInstance.cancel();\n    };\n    wrappedFunc.isPending = () => {\n      return !!debouncedFunc.current;\n    };\n    wrappedFunc.flush = () => {\n      return debouncedFuncInstance.flush();\n    };\n    return wrappedFunc;\n  }, [func, delay, options]);\n  useEffect(() => {\n    debouncedFunc.current = debounce(func, delay, options);\n  }, [func, delay, options]);\n  return debounced;\n}\nfunction useDebounceValue(initialValue, delay, options) {\n  const eq = (options == null ? void 0 : options.equalityFn) ?? ((left, right) => left === right);\n  const unwrappedInitialValue = initialValue instanceof Function ? initialValue() : initialValue;\n  const [debouncedValue, setDebouncedValue] = useState(unwrappedInitialValue);\n  const previousValueRef = useRef(unwrappedInitialValue);\n  const updateDebouncedValue = useDebounceCallback(\n    setDebouncedValue,\n    delay,\n    options\n  );\n  if (!eq(previousValueRef.current, unwrappedInitialValue)) {\n    updateDebouncedValue(unwrappedInitialValue);\n    previousValueRef.current = unwrappedInitialValue;\n  }\n  return [debouncedValue, updateDebouncedValue];\n}\nfunction useDocumentTitle(title, options = {}) {\n  const { preserveTitleOnUnmount = true } = options;\n  const defaultTitle = useRef(null);\n  useIsomorphicLayoutEffect(() => {\n    defaultTitle.current = window.document.title;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    window.document.title = title;\n  }, [title]);\n  useUnmount(() => {\n    if (!preserveTitleOnUnmount && defaultTitle.current) {\n      window.document.title = defaultTitle.current;\n    }\n  });\n}\nfunction useHover(elementRef) {\n  const [value, setValue] = useState(false);\n  const handleMouseEnter = () => {\n    setValue(true);\n  };\n  const handleMouseLeave = () => {\n    setValue(false);\n  };\n  useEventListener(\"mouseenter\", handleMouseEnter, elementRef);\n  useEventListener(\"mouseleave\", handleMouseLeave, elementRef);\n  return value;\n}\nfunction useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange\n} = {}) {\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!ref)\n      return;\n    if (!(\"IntersectionObserver\" in window))\n      return;\n    if (frozen)\n      return;\n    let unobserve;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n        entries.forEach((entry) => {\n          const isIntersecting = entry.isIntersecting && thresholds.some((threshold2) => entry.intersectionRatio >= threshold2);\n          setState({ isIntersecting, entry });\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = void 0;\n          }\n        });\n      },\n      { threshold, root, rootMargin }\n    );\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [\n    ref,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(threshold),\n    root,\n    rootMargin,\n    frozen,\n    freezeOnceVisible\n  ]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: void 0 });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [\n    setRef,\n    !!state.isIntersecting,\n    state.entry\n  ];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nfunction useIsClient() {\n  const [isClient, setClient] = useState(false);\n  useEffect(() => {\n    setClient(true);\n  }, []);\n  return isClient;\n}\nfunction useIsMounted() {\n  const isMounted = useRef(false);\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return useCallback(() => isMounted.current, []);\n}\nfunction useMap(initialState = /* @__PURE__ */ new Map()) {\n  const [map, setMap] = useState(new Map(initialState));\n  const actions = {\n    set: useCallback((key, value) => {\n      setMap((prev) => {\n        const copy = new Map(prev);\n        copy.set(key, value);\n        return copy;\n      });\n    }, []),\n    setAll: useCallback((entries) => {\n      setMap(() => new Map(entries));\n    }, []),\n    remove: useCallback((key) => {\n      setMap((prev) => {\n        const copy = new Map(prev);\n        copy.delete(key);\n        return copy;\n      });\n    }, []),\n    reset: useCallback(() => {\n      setMap(() => /* @__PURE__ */ new Map());\n    }, [])\n  };\n  return [map, actions];\n}\n\n// src/useOnClickOutside/useOnClickOutside.ts\nfunction useOnClickOutside(ref, handler, eventType = \"mousedown\", eventListenerOptions = {}) {\n  useEventListener(\n    eventType,\n    (event) => {\n      const target = event.target;\n      if (!target || !target.isConnected) {\n        return;\n      }\n      const isOutside = Array.isArray(ref) ? ref.filter((r) => Boolean(r.current)).every((r) => r.current && !r.current.contains(target)) : ref.current && !ref.current.contains(target);\n      if (isOutside) {\n        handler(event);\n      }\n    },\n    void 0,\n    eventListenerOptions\n  );\n}\nvar IS_SERVER3 = typeof window === \"undefined\";\nfunction useReadLocalStorage(key, options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER3) {\n    initializeWithValue = false;\n  }\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return null;\n      }\n      return parsed;\n    },\n    [options]\n  );\n  const readValue = useCallback(() => {\n    if (IS_SERVER3) {\n      return null;\n    }\n    try {\n      const raw = window.localStorage.getItem(key);\n      return raw ? deserializer(raw) : null;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \\u201C${key}\\u201D:`, error);\n      return null;\n    }\n  }, [key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return void 0;\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"local-storage\", handleStorageChange);\n  return storedValue;\n}\nvar initialSize = {\n  width: void 0,\n  height: void 0\n};\nfunction useResizeObserver(options) {\n  const { ref, box = \"content-box\" } = options;\n  const [{ width, height }, setSize] = useState(initialSize);\n  const isMounted = useIsMounted();\n  const previousSize = useRef({ ...initialSize });\n  const onResize = useRef(void 0);\n  onResize.current = options.onResize;\n  useEffect(() => {\n    if (!ref.current)\n      return;\n    if (typeof window === \"undefined\" || !(\"ResizeObserver\" in window))\n      return;\n    const observer = new ResizeObserver(([entry]) => {\n      const boxProp = box === \"border-box\" ? \"borderBoxSize\" : box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n      const newWidth = extractSize(entry, boxProp, \"inlineSize\");\n      const newHeight = extractSize(entry, boxProp, \"blockSize\");\n      const hasChanged = previousSize.current.width !== newWidth || previousSize.current.height !== newHeight;\n      if (hasChanged) {\n        const newSize = { width: newWidth, height: newHeight };\n        previousSize.current.width = newWidth;\n        previousSize.current.height = newHeight;\n        if (onResize.current) {\n          onResize.current(newSize);\n        } else {\n          if (isMounted()) {\n            setSize(newSize);\n          }\n        }\n      }\n    });\n    observer.observe(ref.current, { box });\n    return () => {\n      observer.disconnect();\n    };\n  }, [box, ref, isMounted]);\n  return { width, height };\n}\nfunction extractSize(entry, box, sizeType) {\n  if (!entry[box]) {\n    if (box === \"contentBoxSize\") {\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n    return void 0;\n  }\n  return Array.isArray(entry[box]) ? entry[box][0][sizeType] : (\n    // @ts-ignore Support Firefox's non-standard behavior\n    entry[box][sizeType]\n  );\n}\nvar IS_SERVER4 = typeof window === \"undefined\";\nfunction useScreen(options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER4) {\n    initializeWithValue = false;\n  }\n  const readScreen = () => {\n    if (IS_SERVER4) {\n      return void 0;\n    }\n    return window.screen;\n  };\n  const [screen, setScreen] = useState(() => {\n    if (initializeWithValue) {\n      return readScreen();\n    }\n    return void 0;\n  });\n  const debouncedSetScreen = useDebounceCallback(\n    setScreen,\n    options.debounceDelay\n  );\n  function handleSize() {\n    const newScreen = readScreen();\n    const setSize = options.debounceDelay ? debouncedSetScreen : setScreen;\n    if (newScreen) {\n      const {\n        width,\n        height,\n        availHeight,\n        availWidth,\n        colorDepth,\n        orientation,\n        pixelDepth\n      } = newScreen;\n      setSize({\n        width,\n        height,\n        availHeight,\n        availWidth,\n        colorDepth,\n        orientation,\n        pixelDepth\n      });\n    }\n  }\n  useEventListener(\"resize\", handleSize);\n  useIsomorphicLayoutEffect(() => {\n    handleSize();\n  }, []);\n  return screen;\n}\nvar cachedScriptStatuses = /* @__PURE__ */ new Map();\nfunction getScriptNode(src) {\n  const node = document.querySelector(\n    `script[src=\"${src}\"]`\n  );\n  const status = node == null ? void 0 : node.getAttribute(\"data-status\");\n  return {\n    node,\n    status\n  };\n}\nfunction useScript(src, options) {\n  const [status, setStatus] = useState(() => {\n    if (!src || (options == null ? void 0 : options.shouldPreventLoad)) {\n      return \"idle\";\n    }\n    if (typeof window === \"undefined\") {\n      return \"loading\";\n    }\n    return cachedScriptStatuses.get(src) ?? \"loading\";\n  });\n  useEffect(() => {\n    if (!src || (options == null ? void 0 : options.shouldPreventLoad)) {\n      return;\n    }\n    const cachedScriptStatus = cachedScriptStatuses.get(src);\n    if (cachedScriptStatus === \"ready\" || cachedScriptStatus === \"error\") {\n      setStatus(cachedScriptStatus);\n      return;\n    }\n    const script = getScriptNode(src);\n    let scriptNode = script.node;\n    if (!scriptNode) {\n      scriptNode = document.createElement(\"script\");\n      scriptNode.src = src;\n      scriptNode.async = true;\n      if (options == null ? void 0 : options.id) {\n        scriptNode.id = options.id;\n      }\n      scriptNode.setAttribute(\"data-status\", \"loading\");\n      document.body.appendChild(scriptNode);\n      const setAttributeFromEvent = (event) => {\n        const scriptStatus = event.type === \"load\" ? \"ready\" : \"error\";\n        scriptNode == null ? void 0 : scriptNode.setAttribute(\"data-status\", scriptStatus);\n      };\n      scriptNode.addEventListener(\"load\", setAttributeFromEvent);\n      scriptNode.addEventListener(\"error\", setAttributeFromEvent);\n    } else {\n      setStatus(script.status ?? cachedScriptStatus ?? \"loading\");\n    }\n    const setStateFromEvent = (event) => {\n      const newStatus = event.type === \"load\" ? \"ready\" : \"error\";\n      setStatus(newStatus);\n      cachedScriptStatuses.set(src, newStatus);\n    };\n    scriptNode.addEventListener(\"load\", setStateFromEvent);\n    scriptNode.addEventListener(\"error\", setStateFromEvent);\n    return () => {\n      if (scriptNode) {\n        scriptNode.removeEventListener(\"load\", setStateFromEvent);\n        scriptNode.removeEventListener(\"error\", setStateFromEvent);\n      }\n      if (scriptNode && (options == null ? void 0 : options.removeOnUnmount)) {\n        scriptNode.remove();\n        cachedScriptStatuses.delete(src);\n      }\n    };\n  }, [src, options == null ? void 0 : options.shouldPreventLoad, options == null ? void 0 : options.removeOnUnmount, options == null ? void 0 : options.id]);\n  return status;\n}\nvar IS_SERVER5 = typeof window === \"undefined\";\nfunction useScrollLock(options = {}) {\n  const { autoLock = true, lockTarget, widthReflow = true } = options;\n  const [isLocked, setIsLocked] = useState(false);\n  const target = useRef(null);\n  const originalStyle = useRef(null);\n  const lock = () => {\n    if (target.current) {\n      const { overflow, paddingRight } = target.current.style;\n      originalStyle.current = { overflow, paddingRight };\n      if (widthReflow) {\n        const offsetWidth = target.current === document.body ? window.innerWidth : target.current.offsetWidth;\n        const currentPaddingRight = parseInt(window.getComputedStyle(target.current).paddingRight, 10) || 0;\n        const scrollbarWidth = offsetWidth - target.current.scrollWidth;\n        target.current.style.paddingRight = `${scrollbarWidth + currentPaddingRight}px`;\n      }\n      target.current.style.overflow = \"hidden\";\n      setIsLocked(true);\n    }\n  };\n  const unlock = () => {\n    if (target.current && originalStyle.current) {\n      target.current.style.overflow = originalStyle.current.overflow;\n      if (widthReflow) {\n        target.current.style.paddingRight = originalStyle.current.paddingRight;\n      }\n    }\n    setIsLocked(false);\n  };\n  useIsomorphicLayoutEffect(() => {\n    if (IS_SERVER5)\n      return;\n    if (lockTarget) {\n      target.current = typeof lockTarget === \"string\" ? document.querySelector(lockTarget) : lockTarget;\n    }\n    if (!target.current) {\n      target.current = document.body;\n    }\n    if (autoLock) {\n      lock();\n    }\n    return () => {\n      unlock();\n    };\n  }, [autoLock, lockTarget, widthReflow]);\n  return { isLocked, lock, unlock };\n}\nvar IS_SERVER6 = typeof window === \"undefined\";\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { initializeWithValue = true } = options;\n  const serializer = useCallback(\n    (value) => {\n      if (options.serializer) {\n        return options.serializer(value);\n      }\n      return JSON.stringify(value);\n    },\n    [options]\n  );\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return defaultValue;\n      }\n      return parsed;\n    },\n    [options, initialValue]\n  );\n  const readValue = useCallback(() => {\n    const initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;\n    if (IS_SERVER6) {\n      return initialValueToUse;\n    }\n    try {\n      const raw = window.sessionStorage.getItem(key);\n      return raw ? deserializer(raw) : initialValueToUse;\n    } catch (error) {\n      console.warn(`Error reading sessionStorage key \\u201C${key}\\u201D:`, error);\n      return initialValueToUse;\n    }\n  }, [initialValue, key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  });\n  const setValue = useEventCallback((value) => {\n    if (IS_SERVER6) {\n      console.warn(\n        `Tried setting sessionStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    try {\n      const newValue = value instanceof Function ? value(readValue()) : value;\n      window.sessionStorage.setItem(key, serializer(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new StorageEvent(\"session-storage\", { key }));\n    } catch (error) {\n      console.warn(`Error setting sessionStorage key \\u201C${key}\\u201D:`, error);\n    }\n  });\n  const removeValue = useEventCallback(() => {\n    if (IS_SERVER6) {\n      console.warn(\n        `Tried removing sessionStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n    window.sessionStorage.removeItem(key);\n    setStoredValue(defaultValue);\n    window.dispatchEvent(new StorageEvent(\"session-storage\", { key }));\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"session-storage\", handleStorageChange);\n  return [storedValue, setValue, removeValue];\n}\nfunction useStep(maxStep) {\n  const [currentStep, setCurrentStep] = useState(1);\n  const canGoToNextStep = currentStep + 1 <= maxStep;\n  const canGoToPrevStep = currentStep - 1 > 0;\n  const setStep = useCallback(\n    (step) => {\n      const newStep = step instanceof Function ? step(currentStep) : step;\n      if (newStep >= 1 && newStep <= maxStep) {\n        setCurrentStep(newStep);\n        return;\n      }\n      throw new Error(\"Step not valid\");\n    },\n    [maxStep, currentStep]\n  );\n  const goToNextStep = useCallback(() => {\n    if (canGoToNextStep) {\n      setCurrentStep((step) => step + 1);\n    }\n  }, [canGoToNextStep]);\n  const goToPrevStep = useCallback(() => {\n    if (canGoToPrevStep) {\n      setCurrentStep((step) => step - 1);\n    }\n  }, [canGoToPrevStep]);\n  const reset = useCallback(() => {\n    setCurrentStep(1);\n  }, []);\n  return [\n    currentStep,\n    {\n      goToNextStep,\n      goToPrevStep,\n      canGoToNextStep,\n      canGoToPrevStep,\n      setStep,\n      reset\n    }\n  ];\n}\n\n// src/useTernaryDarkMode/useTernaryDarkMode.ts\nvar COLOR_SCHEME_QUERY2 = \"(prefers-color-scheme: dark)\";\nvar LOCAL_STORAGE_KEY2 = \"usehooks-ts-ternary-dark-mode\";\nfunction useTernaryDarkMode({\n  defaultValue = \"system\",\n  localStorageKey = LOCAL_STORAGE_KEY2,\n  initializeWithValue = true\n} = {}) {\n  const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY2, { initializeWithValue });\n  const [mode, setMode] = useLocalStorage(localStorageKey, defaultValue, {\n    initializeWithValue\n  });\n  const isDarkMode = mode === \"dark\" || mode === \"system\" && isDarkOS;\n  const toggleTernaryDarkMode = () => {\n    const modes = [\"light\", \"system\", \"dark\"];\n    setMode((prevMode) => {\n      const nextIndex = (modes.indexOf(prevMode) + 1) % modes.length;\n      return modes[nextIndex];\n    });\n  };\n  return {\n    isDarkMode,\n    ternaryDarkMode: mode,\n    setTernaryDarkMode: setMode,\n    toggleTernaryDarkMode\n  };\n}\nfunction useTimeout(callback, delay) {\n  const savedCallback = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    if (!delay && delay !== 0) {\n      return;\n    }\n    const id = setTimeout(() => {\n      savedCallback.current();\n    }, delay);\n    return () => {\n      clearTimeout(id);\n    };\n  }, [delay]);\n}\nfunction useToggle(defaultValue) {\n  const [value, setValue] = useState(!!defaultValue);\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n  return [value, toggle, setValue];\n}\nvar IS_SERVER7 = typeof window === \"undefined\";\nfunction useWindowSize(options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER7) {\n    initializeWithValue = false;\n  }\n  const [windowSize, setWindowSize] = useState(() => {\n    if (initializeWithValue) {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n    }\n    return {\n      width: void 0,\n      height: void 0\n    };\n  });\n  const debouncedSetWindowSize = useDebounceCallback(\n    setWindowSize,\n    options.debounceDelay\n  );\n  function handleSize() {\n    const setSize = options.debounceDelay ? debouncedSetWindowSize : setWindowSize;\n    setSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n  }\n  useEventListener(\"resize\", handleSize);\n  useIsomorphicLayoutEffect(() => {\n    handleSize();\n  }, []);\n  return windowSize;\n}\n\nexport { useBoolean, useClickAnyWhere, useCopyToClipboard, useCountdown, useCounter, useDarkMode, useDebounceCallback, useDebounceValue, useDocumentTitle, useEventCallback, useEventListener, useHover, useIntersectionObserver, useInterval, useIsClient, useIsMounted, useIsomorphicLayoutEffect, useLocalStorage, useMap, useMediaQuery, useOnClickOutside, useReadLocalStorage, useResizeObserver, useScreen, useScript, useScrollLock, useSessionStorage, useStep, useTernaryDarkMode, useTimeout, useToggle, useUnmount, useWindowSize };\n"],"names":["React.useMemo","React.useState","React.useSyncExternalStore","React.useCallback","React.useEffect","useRef","useEffect","useMemo","debounce","useState"],"mappings":"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"}